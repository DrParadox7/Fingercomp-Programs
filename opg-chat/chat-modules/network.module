if not cfg.net.enabled then
  return false, "disabled in config"
end

local com = require("component")
local comp = require("computer")
local srl = require("serialization")

assert(com.isAvailable("os_datablock") or com.isAvailable("data"), "data card/block required")
assert(com.isAvailable("modem"), "modem card required")

local modem = com.modem
local data

if modem.isWireless() then
  modem.setStrength(cfg.net.modem_strength)
end

for port in pairs(cfg.net.ports) do
  assert(type(port) == "string", "not a string: " .. tostring(port))
  modem.open(tonumber(port))
end

EvEng:stdEvent("modem_message")

local connections = {}
storage.connections = {}

if com.isAvailable("data") then
  data = com.data
elseif com.isAvailable("os_datablock") then
  data = com.os_datablock
end

local function byte2hex(str)
  return str:gsub(".", function(char)
    return ("%02X"):format(string.byte(char))
  end)
end

local function hash(text)
  return byte2hex(data.md5(text))
end

local function random(len)
  return byte2hex(data.random(len))
end

EvEng:subscribe("modem_message", 0, function(evt)
  local addr, sender, port, distance, user, cmd, pass, msg = evt[1], evt[2], evt[3], evt[4], evt[5], evt[6], evt[7], evt[8]
  local data = evt.get()
  local args = {}
  for i = 9, #data, 1 do
    args[#args] = data[i]
  end
  port = math.tointeger(port)
  if cfg.net.ports[tostring(port)] == nil then
    -- Ignore
    return -1
  end
  if cfg.net.ports[tostring(port)] ~= true then
    for _, allowed in pairs(cfg.net.ports[tostring(port)]) do
      if not sender:sub(1, #allowed) == allowed then
        modem.send(sender, port, false, "error", "address is not whitelisted")
        return -1
      end
    end
  end
  if type(user) ~= "string" or type(cmd) ~= "string" or type(pass) ~= "string" then
    modem.send(sender, port, false, "error", "wrong message format")
    return -1
  end
  if cmd == "auth" then
    if connections[sender] then
      modem.send(sender, port, false, "error", "there is already an open connection for this address")
      return -1
    end
    if not user:match("^[a-zA-Z0-9-`_^]+$") then
      modem.send(sender, port, false, "error", "erroneous nickname")
      return -1
    end
    if users[user] then
      modem.send(sender, port, false, "error", "nickname is already in use")
      return -1
    end
    if not pass then
      modem.send(sender, port, false, "error", "no password given")
      return -1
    end
    if not cfg.users[user] then
    elseif cfg.users[user].pass == "" and pass == "" then
    elseif cfg.users[user].pass ~= hash(pass) then
      modem.send(sender, port, false, "error", "wrong password")
      return -1
    end
    local success, reason = apcall(addUser, user, true)
    if not success then
      modem.send(sender, port, false, "error", "could not auth: " .. (reason or "unknown reason"))
      return -1
    end
    local session = random(8)
    connections[sender] = {user = user, port = port, pass = session, ping = comp.uptime(), sentPing = false, pingMsg = ""}
    joinN(cfg.main_channel, user)
    modem.send(sender, port, true, "keep", "auth", session)
  else
    if not users[user] then
      modem.send(sender, port, false, "error", "not authenticated")
      return -1
    end
    if not connections[sender] or connections[sender].user ~= user or connections[sender].pass ~= pass then
      modem.send(sender, port, false, "error", "wrong auth")
      return -1
    end
    if cmd == "quit" then
      msg = msg or ""
      quitN(connections[sender].user, msg)
      connections[sender] = nil
      modem.send(sender, port, true, "close")
    end
    if not msg then
      modem.send(sender, port, false, "keep", "no message given")
      return -1
    end
    if cmd == "msg" then
      EvEng:push(events.chat_message{addr = addr, user = user, sender = sender, msg = tostring(msg)})
      modem.send(sender, port, true, "keep", "ok")
    elseif cmd == "pong" then
      if not connections[sender].sentPing then
        modem.send(sender, port, false, "keep", "unexpected pong")
        return -1
      end
      if connections[sender].pingMsg ~= msg then
        modem.send(sender, port, false, "keep", "wrong ping message")
        return -1
      end
      connections[sender].pingMsg = ""
      connections[sender].sentPing = false
      connections[sender].ping = comp.uptime()
    elseif cmd == "chaninfo" then
      if not channels[tostring(msg)] or not channels[tostring(msg)].users[connections[sender].user] then
        modem.send(sender, port, false, "keep", "you are not in the channel")
        return -1
      end
      local chan = tostring(msg)
      local data = {
        info =    channels[chan].info,
        users =   channels[chan].users,
        modes =   channels[chan].modes,
        topic =   channels[chan].topic,
        banned =  channels[chan].banned,
        exempt =  channels[chan].exempt
      }
      modem.send(sender, port, true, "keep", srl.serialize(data))
    elseif cmd == "userinfo" then
      if not users[tostring(msg)] then
        modem.send(sender, port, false, "keep", "no such user")
        return -1
      end
      local user = tostring(msg)
      local self = user == connections[sender].user
      local data = {
        channels =          self and users[user].channels       or nil,
        modes =             self and users[user].modes          or nil,
        prompt =            self and users[user].prompt         or nil,
        history =           self and users[user].history        or nil,
        tabStart =          self and users[user].tabStart       or nil,
        shown =             self and users[user].shown          or nil,
        channelOffsets =    self and users[user].channelOffsets or nil,
        net =                        users[user].net
      }
      modem.send(sender, port, true, "keep", srl.serialize(data))
    end
  end
end)

local timer = cfg.net.ping.enabled and event.timer(1, function()
    for conn, value in pairs(connections) do
      if value.ping + cfg.net.ping.interval < comp.uptime() and not value.sentPing then
        value.sentPing = true
        value.pingMsg = random(16)
        modem.send(conn, value.port, "ping", value.pingMsg, comp.uptime())
      elseif value.sentPing and value.ping + cfg.net.ping.interval + cfg.net.ping.timeout < comp.uptime() then
        modem.send(conn, value.port, false, "close", "ping timeout")
        quitN(value.user, "Ping timeout (" .. tostring(math.tointeger(cfg.net.ping.timeout)) .. " seconds)")
        connections[conn] = nil
      end
    end
  end, math.huge)

EvEng:subscribe("msg", 0, function(evt)
  local time, chan, nick, msg, rec = evt.time, evt.chan, evt.nick, evt.msg, evt.rec
  for conn, value in pairs(connections) do
    if #rec == 0 or isin(rec, value.user) then
      modem.send(conn, value.port, "event", "chat", chan, nick, msg, srl.serialize(rec))
    end
  end
end)

EvEng:subscribe("notice", 0, function(evt)
  local time, chan, noticeType, notice, rec = evt.time, evt.chan, evt.noticeType, evt.notice, evt.rec
  for conn, value in pairs(connections) do
    if #rec == 0 or isin(rec, value.user) then
      modem.send(conn, value.port, "event", "notice", chan, noticeType, notice, srl.serialize(rec))
    end
  end
end)

EvEng:subscribe("pm", 0, function(evt)
  local time, user, addressee, msg = evt.time, evt.user, evt.addressee, evt.msg
  for conn, value in pairs(connections) do
    if isin({addressee, user}, value.user) then
      modem.send(conn, value.port, "event", "pm", user, addressee, msg)
    end
  end
end)

EvEng:subscribe("join", 0, function(evt)
  local time, chan, user = evt.time, evt.chan, evt.user
  for conn, value in pairs(connections) do
    if channels[chan].users[value.user] then
      modem.send(conn, value.port, "event", "join", chan, user)
    end
  end
end)

EvEng:subscribe("part", 0, function(evt)
  local time, chan, user, reason = evt.time, evt.chan, evt.user, evt.reason
  for conn, value in pairs(connections) do
    if channels[chan] and channels[chan].users[value.user] then
      modem.send(conn, value.port, "event", "part", chan, user, reason)
    end
  end
end)

EvEng:subscribe("quit", 0, function(evt)
  local time, user, reason, chans = evt.time, evt.user, evt.reason, evt.chans
  for conn, value in pairs(connections) do
    for _, chan in pairs(chans) do
      if channels[chan] and channels[chan].users[value.user] then
        modem.send(conn, value.port, "event", "quit", user, reason)
        break
      end
    end
  end
end)

EvEng:subscribe("stop", 0, function(evt)
  local time = evt.time
  for conn, value in pairs(connections) do
    modem.send(conn, value.port, false, "close", "server is stopping")
    connections[conn] = nil
  end
  for port in pairs(cfg.net.ports) do
    modem.close(tonumber(port))
  end
  if timer then
    event.cancel(timer)
  end
end)

-- vim: expandtab tabstop=2 shiftwidth=2 syntax=lua filetype=lua :
